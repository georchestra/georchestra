<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:aop="http://www.springframework.org/schema/aop"
       xmlns:context="http://www.springframework.org/schema/context"
       xmlns:jee="http://www.springframework.org/schema/jee"
       xmlns:tx="http://www.springframework.org/schema/tx"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:jpa="http://www.springframework.org/schema/data/jpa"
       xsi:schemaLocation="http://www.springframework.org/schema/aop
                           http://www.springframework.org/schema/aop/spring-aop-2.5.xsd
                           http://www.springframework.org/schema/beans
                           http://www.springframework.org/schema/beans/spring-beans-2.5.xsd
                           http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-2.5.xsd
                           http://www.springframework.org/schema/jee http://www.springframework.org/schema/jee/spring-jee-2.5.xsd
                           http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx-2.5.xsd
                           http://camel.apache.org/schema/spring
                           http://camel.apache.org/schema/spring/camel-spring-2.16.1.xsd http://www.springframework.org/schema/data/jpa http://www.springframework.org/schema/data/jpa/spring-jpa.xsd">


    <!-- have a properties file with the defaults with the possibility to override them with
         JRE or system environment variables-->
    <bean id="bridgePropertyPlaceholder"
          class="org.apache.camel.spring.spi.BridgePropertyPlaceholderConfigurer">
        <property name="location" value="classpath:atlas.properties"/>
        <property name="systemPropertiesModeName" value="SYSTEM_PROPERTIES_MODE_OVERRIDE"/>
        <property name="searchSystemEnvironment" value="true"/>
    </bean>

    <bean id="dataSource" class="com.mchange.v2.c3p0.ComboPooledDataSource" destroy-method="close">
        <property name="driverClass" value="org.postgresql.Driver"/>
        <property name="jdbcUrl" value="${psql.url}"/>
        <property name="user" value="${psql.user}"/>
        <property name="password" value="${psql.pass}"/>
        <property name="maxPoolSize" value="5"/>
        <property name="minPoolSize" value="1"/>
    </bean>

    <bean id="populateProperties" class="org.georchestra.atlas.CamelPopulatePropertiesComponent"/>
    <bean id="specAsPdf" class="org.georchestra.atlas.CamelMapfishPrintComponent" init-method="init" />

    <bean id="setState" class="org.georchestra.atlas.CamelSetStateComponent"/>

    <!--<bean id="myTransactionManager" class="org.springframework.orm.jpa.JpaTransactionManager">-->
      <!--<property name="entityManagerFactory" ref="entityManagerFactory"/>-->
    <!--</bean>-->
    <bean id="transactionManager" class="org.springframework.jdbc.datasource.DataSourceTransactionManager">
        <property name="dataSource" ref="dataSource"></property>
    </bean>


    <bean id="jpa" class="org.apache.camel.component.jpa.JpaComponent">
        <property name="entityManagerFactory" ref="entityManagerFactory"/>
        <property name="transactionManager" ref="transactionManager"/>
    </bean>

    <bean id="entityManagerFactory" class="org.springframework.orm.jpa.LocalContainerEntityManagerFactoryBean">
        <property name="persistenceUnitName" value="myPU"/>
        <property name="dataSource" ref="dataSource"/>
        <property name="jpaProperties">
            <props>
                <prop key="hibernate.dialect">org.hibernate.dialect.PostgreSQL94Dialect</prop>
                <prop key="hibernate.show_sql">false</prop>
                <prop key="hibernate.format_sql">false</prop>
                <prop key="hibernate.hbm2ddl.auto">update</prop>
            </props>
        </property>

    </bean>

    <!-- A context component that has some utility components to handle typical tasks -->
    <camelContext id="atlas" xmlns="http://camel.apache.org/schema/spring"
                  xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
                  streamCache="true">
        <dataFormats>
            <json id="gson" library="Gson" />
        </dataFormats>

        <!--<routeContextRef ref="mapfish"/>-->

        <restConfiguration component="servlet">
            <componentProperty key="enableCors" value="true"/>
            <dataFormatProperty key="prettyPrint" value="true"/>
        </restConfiguration>

        <!--
        Route for requesting Mapfish Print to generate a PDF.
        Inputs:
            - the body must contain the JSON request.
            - property.printBase must have the base URL of the Mapfish Print service.
        -->
        <rest>
            <post uri="/atlas/print" consumes="application/json" produces="application/json" enableCORS="true">
                <to uri="direct:save_print_request"/>
            </post>
            <get uri="/test">
                <to uri="direct:test"/>
            </get>
        </rest>

        <route id="test">
            <from uri="direct:test"/>

            <transform>
                <simple>Hello it Works !</simple>
            </transform>
        </route>


        <route id="save_print_request">
            <from uri="direct:save_print_request"/>

            <to uri="direct:checkArgs"/>

            <!-- store in DB queue -->
            <to uri="jpa:org.georchestra.atlas.AtlasJob?persistenceUnit=myPU"/>

            <log message="Storing request to DB with ID : ${body.id}" loggingLevel="INFO"/>

            <transform>
                <simple>${body.id}</simple>
            </transform>

        </route>

        <route id="checkArgs">
            <from uri="direct:checkArgs"/>

            <!-- check json format -->
            <unmarshal ref="gson"/>
            <marshal ref="gson"/>

        </route>


        <route id="split_and_send_request">
            <from uri="jpa:org.georchestra.atlas.AtlasJob?transactionManager=#transactionManager&amp;persistenceUnit=myPU&amp;consumer.lockModeType=NONE&amp;consumer.delay=2000&amp;maximumResults=1&amp;consumeDelete=false&amp;consumer.query=FROM org.georchestra.atlas.AtlasJob WHERE state = 'TODO' ORDER BY id"/>

            <log message="New request from DB" loggingLevel="INFO"/>

            <setProperty propertyName="dummy">
                <groovy>request.body.setState(org.georchestra.atlas.AtlasJobState.IN_PROGRESS)</groovy>
            </setProperty>

            <setProperty propertyName="jobId">
                <simple>${body.id}</simple>
            </setProperty>

            <!-- Store job as object -->
            <setProperty propertyName="originalObject">
                <simple>${body}</simple>
            </setProperty>

            <transform>
                <groovy>request.body.getQuery()</groovy>
            </transform>

            <!-- Backup original Json-->
            <setProperty propertyName="rawJson">
                <simple>${body}</simple>
            </setProperty>

            <!-- parse json -->
            <unmarshal ref="gson"/>

            <setProperty propertyName="layout">
                <simple>${body[layout]}</simple>
            </setProperty>

            <setProperty propertyName="dpi">
                <simple>${body[dpi]}</simple>
            </setProperty>

            <setProperty propertyName="displayLegend">
                <simple>${body[displayLegend]}</simple>
            </setProperty>

            <setProperty propertyName="outputFormat">
                <simple>${body[outputFormat]}</simple>
            </setProperty>

            <setProperty propertyName="outputFilename">
                <simple>${body[outputFilename]}</simple>
            </setProperty>

            <setProperty propertyName="projection">
                <simple>${body[projection]}</simple>
            </setProperty>

            <!-- generate layers and legendURL property -->
            <to uri="bean:populateProperties"/>

            <split stopOnException="true">
                <simple>${body[pages]}</simple>
                <choice>
                    <when>
                        <simple>${exchangeProperty.displayLegend} == true</simple>
                        <transform>
                            <simple>
                                { "layout": "${exchangeProperty.layout}",
                                  "outputFormat": "PDF",
                                  "attributes": {
                                    "title": "${body[title]}",
                                    "subtitle": "${body[subtitle]}",
                                    "legendURL": "${exchangeProperty.legendURL}",
                                    "map": {
                                        "dpi": ${exchangeProperty.dpi},
                                        "projection": "${exchangeProperty.projection}",
                                        "center": ${body[center]},
                                        "scale": ${body[scale]},
                                        "layers": ${exchangeProperty.layers}
                                    }
                                  }
                                }
                            </simple>
                        </transform>
                    </when>
                    <otherwise>
                        <transform>
                            <simple>
                                { "layout": "${exchangeProperty.layout}",
                                "outputFormat": "PDF",
                                "attributes": {
                                "title": "${body[title]}",
                                "subtitle": "${body[subtitle]}",
                                "map": {
                                "dpi": ${exchangeProperty.dpi},
                                "projection": "${exchangeProperty.projection}",
                                "center": ${body[center]},
                                "scale": ${body[scale]},
                                "layers": ${exchangeProperty.layers}
                                }
                                }
                                }
                            </simple>
                        </transform>
                    </otherwise>
                </choice>

                <log message="print request : ${body}" loggingLevel="INFO"/>

                <setProperty propertyName="printBase">
                    <constant>http://print:8080/print/atlas</constant>
                </setProperty>
                <!--
                <to uri="direct:print"/>
                -->
                <to uri="bean:specAsPdf"/>
                <to uri="file://?fileName=/tmp/tmp/${property.jobId}/${property.CamelSplitIndex}.pdf"/>

                <log message="${property.jobId} / ${property.CamelSplitIndex} Done !" loggingLevel="INFO"/>

            </split>

            <setHeader headerName="CamelExecCommandWorkingDir">
                <simple>/tmp/tmp/${property.jobId}</simple>
            </setHeader>

            <!-- Clean STDIN before launching scripts -->
            <transform>
                <constant/>
            </transform>

            <choice>
                    <when>
                        <simple>${exchangeProperty.outputFormat} == "pdf"</simple>
                        <to uri="exec:/bin/sh?useStderrOnEmptyStdout=true&amp;args=-c &quot;/usr/bin/pdfjoin --outfile /proc/self/fd/1 *.pdf&quot;"/>
                    </when>
                    <otherwise>
                        <to uri="exec:/bin/sh?useStderrOnEmptyStdout=true&amp;args=-c &quot;/usr/bin/zip - *.pdf&quot;"/>
                    </otherwise>
            </choice>

            <choice>
                <when>
                    <simple>${body.exitValue} != 0</simple>
                    <to uri="log:zip?level=ERROR"/>
                    <throwException message="Failed to zip the files" exceptionType="java.lang.RuntimeException"/>
                </when>
                <otherwise>
                    <to uri="file://?fileName=/tmp/output/${property.outputFilename}"/>
                </otherwise>
            </choice>

            <transform>
                <simple>${property.originalObject}</simple>
            </transform>

            <!-- Change state of job -->
            <setProperty propertyName="dummy">
                <groovy>request.body.setState(org.georchestra.atlas.AtlasJobState.DONE)</groovy>
            </setProperty>

			<!-- Send a mail once done -->
			<transform>
				<simple>Bonjour,

Votre impression est dorénavant terminée ; elle est disponible à l'addresse:
${body.id}.

Bien cordialement,

-- Pierre Mauduit
				</simple>
			</transform>
			
			<to uri="smtp://localhost?to%3Dpierre.mauduit%40camptocamp.com%26from%3Dnoreply%40camptocamp.com%26subject%3DAtlas%20-%20Votre%20demande%20de%20cr%C3%A9ation"></to>
        </route>

    </camelContext>



</beans>
