<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:aop="http://www.springframework.org/schema/aop"
       xmlns:context="http://www.springframework.org/schema/context"
       xmlns:jee="http://www.springframework.org/schema/jee"
       xmlns:tx="http://www.springframework.org/schema/tx"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:jpa="http://www.springframework.org/schema/data/jpa"
       xsi:schemaLocation="http://www.springframework.org/schema/aop
                           http://www.springframework.org/schema/aop/spring-aop-2.5.xsd
                           http://www.springframework.org/schema/beans
                           http://www.springframework.org/schema/beans/spring-beans-2.5.xsd
						   http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd
                           http://www.springframework.org/schema/jee http://www.springframework.org/schema/jee/spring-jee-2.5.xsd
                           http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx-2.5.xsd
                           http://camel.apache.org/schema/spring
                           http://camel.apache.org/schema/spring/camel-spring-2.16.1.xsd http://www.springframework.org/schema/data/jpa http://www.springframework.org/schema/data/jpa/spring-jpa.xsd">

    <context:annotation-config/>

	<context:property-placeholder
		location="file:${georchestra.datadir}/atlas/atlas.properties"
		ignore-resource-not-found="true" ignore-unresolvable="true" order="1" />

	<context:property-placeholder location="classpath:atlas.properties"
		ignore-resource-not-found="true" ignore-unresolvable="true" order="2" />

    <bean id="dataSource" class="com.mchange.v2.c3p0.ComboPooledDataSource" destroy-method="close">
        <property name="driverClass" value="org.postgresql.Driver"/>
        <property name="jdbcUrl" value="${psql.url}"/>
        <property name="user" value="${psql.user}"/>
        <property name="password" value="${psql.pass}"/>
        <property name="maxPoolSize" value="5"/>
        <property name="minPoolSize" value="1"/>
    </bean>

    <bean id="populateProperties" class="org.georchestra.atlas.CamelPopulatePropertiesComponent">
        <property name="baseUrl" value="${atlas.baseUrl}"/>
    </bean>
    
    <bean id="specAsPdf" class="org.georchestra.atlas.CamelMapfishPrintComponent" init-method="init" />

    <bean id="prepareMail" class="org.georchestra.atlas.AtlasMailComponent" init-method="init">
        <property name="georBaseUrl" value="${atlas.baseUrl}" />
        <property name="emailFrom" value="${atlas.emailFrom}" />
        <property name="emailSubject" value="${atlas.emailSubject}" />
    </bean>

    <bean id="transactionManager" class="org.springframework.jdbc.datasource.DataSourceTransactionManager">
        <property name="dataSource" ref="dataSource"></property>
    </bean>


    <bean id="jpa" class="org.apache.camel.component.jpa.JpaComponent">
        <property name="entityManagerFactory" ref="entityManagerFactory"/>
        <property name="transactionManager" ref="transactionManager"/>
    </bean>

    <bean id="entityManagerFactory" class="org.springframework.orm.jpa.LocalContainerEntityManagerFactoryBean">
        <property name="persistenceUnitName" value="myPU"/>
        <property name="dataSource" ref="dataSource"/>
        <property name="jpaProperties">
            <props>
                <prop key="hibernate.dialect">org.hibernate.dialect.PostgreSQL94Dialect</prop>
                <prop key="hibernate.show_sql">false</prop>
                <prop key="hibernate.format_sql">false</prop>
                <prop key="hibernate.hbm2ddl.auto">update</prop>
            </props>
        </property>
    </bean>

    <bean id="georchestraConfiguration" class="org.georchestra.commons.configuration.GeorchestraConfiguration">
        <constructor-arg value="atlas" />
    </bean>

    <!-- A context component that has some utility components to handle typical tasks -->
    <camelContext id="atlas" xmlns="http://camel.apache.org/schema/spring"
                  xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
                  streamCache="true">

		<!-- TODO order ? -->
  		<propertyPlaceholder id="properties" location="classpath:atlas.properties,file:${georchestra.datadir}/atlas/atlas.properties" 
  		ignoreMissingLocation="true" />

        <dataFormats>
            <json id="gson" library="Gson" />
        </dataFormats>

        <restConfiguration component="servlet">
            <componentProperty key="enableCors" value="true"/>
            <dataFormatProperty key="prettyPrint" value="true"/>
        </restConfiguration>

        <!--
        Route for requesting Mapfish Print to generate a PDF.
        Inputs:
            - the body must contain the JSON request.
            - property.printBase must have the base URL of the Mapfish Print service.
        -->
        <rest>
            <post uri="/print" consumes="application/json" produces="application/json" enableCORS="true">
                <to uri="direct:save_print_request"/>
            </post>
        </rest>

		<!-- route which receives the posted data from the rest endpoint /print defined above -->
        <route id="save_print_request">
            <from uri="direct:save_print_request"/>
            <log message="Email from requesting user : ${header['sec-email']}" loggingLevel="INFO"/>
			<setProperty propertyName="requestingUserEmail">
                <simple>header['sec-email']</simple>
            </setProperty>
			<setProperty propertyName="baseUrl">
                <simple>header['sec-email']</simple>
            </setProperty>
            
            <to uri="direct:checkArgs"/>
            <!-- store in DB queue -->
            <to uri="jpa:org.georchestra.atlas.AtlasJob?persistenceUnit=myPU"/>
            <log message="Storing request to DB with ID : ${body.id}" loggingLevel="INFO"/>
            <transform>
                <simple>${body.id}</simple>
            </transform>
        </route>

		<!--  Route which checks data integrity (valid JSON) on input -->
        <route id="checkArgs">
            <from uri="direct:checkArgs"/>
            <!-- check json format -->
            <unmarshal ref="gson"/>
            <marshal ref="gson"/>
        </route>

		<!--  Route which polls the DB and process incoming requests -->
        <route id="split_and_send_request">
        	<!--  polls the DB for incoming requests -->
            <from uri="jpa:org.georchestra.atlas.AtlasJob?transactionManager=#transactionManager&amp;persistenceUnit=myPU&amp;consumer.lockModeType=NONE&amp;consumer.delay=2000&amp;maximumResults=1&amp;consumeDelete=false&amp;consumer.query=FROM org.georchestra.atlas.AtlasJob WHERE state = 'TODO' ORDER BY id"/>
            <log message="New request from DB from ${exchangeProperty.requestingUserEmail}" loggingLevel="INFO"/>
            <!--  Modifies the state of the job -->
            <script>
                <groovy>request.body.setState(org.georchestra.atlas.AtlasJobState.IN_PROGRESS)</groovy>
            </script>
            <setProperty propertyName="jobId">
                <simple>${body.id}</simple>
            </setProperty>
            <!-- Store job as object -->
            <setProperty propertyName="originalObject">
                <simple>${body}</simple>
            </setProperty>
            <transform>
                <groovy>request.body.getQuery()</groovy>
            </transform>
            <!-- Backup original Json-->
            <setProperty propertyName="rawJson">
                <simple>${body}</simple>
            </setProperty>
            <!-- parses json input -->
            <unmarshal ref="gson"/>
            <setProperty propertyName="layout">
                <simple>${body[layout]}</simple>
            </setProperty>
            <setProperty propertyName="dpi">
                <simple>${body[dpi]}</simple>
            </setProperty>
            <setProperty propertyName="displayLegend">
                <simple>${body[displayLegend]}</simple>
            </setProperty>
            <setProperty propertyName="outputFormat">
                <simple>${body[outputFormat]}</simple>
            </setProperty>
            <setProperty propertyName="outputFilename">
                <simple>${body[outputFilename]}</simple>
            </setProperty>
            <setProperty propertyName="projection">
                <simple>${body[projection]}</simple>
            </setProperty>
            <!-- generate layers and legendURL properties -->
            <to uri="bean:populateProperties"/>
			<!--  prints page by page -->
            <split stopOnException="true">
                <simple>${body[pages]}</simple>
                <choice>
                    <when>
                        <simple>${exchangeProperty.displayLegend} == true</simple>
                        <transform>
                            <simple>
                                { "layout": "${exchangeProperty.layout}",
                                  "outputFormat": "${exchangeProperty.outputFormat}",
                                  "attributes": {
                                    "title": "${body[title]}",
                                    "subtitle": "${body[subtitle]}",
                                    "legendURL": "${exchangeProperty.legendURL}",
                                    "map": {
                                        "dpi": ${exchangeProperty.dpi},
                                        "projection": "${exchangeProperty.projection}",
                                        "center": ${body[center]},
                                        "scale": ${body[scale]},
                                        "layers": ${exchangeProperty.layers}
                                    }
                                  }
                                }
                            </simple>
                        </transform>
                    </when>
                    <otherwise>
                        <transform>
                            <simple>
	                            {
								   "layout" : "${exchangeProperty.layout}",
								   "outputFormat" : "${exchangeProperty.outputFormat}",
								   "attributes" : {
								      "map" : {
								         "layers" : ${exchangeProperty.layers},
								         "scale" : ${body[scale]},
								         "center" : ${body[center]},
								         "projection" : "${exchangeProperty.projection}",
								         "dpi" : ${exchangeProperty.dpi}
								      },
								      "title" : "${body[title]}",
								      "subtitle" : "${body[subtitle]}"
								   }
								}
		                    </simple>
                        </transform>
                    </otherwise>
                </choice>
                <log message="print request : ${body}" loggingLevel="INFO"/>
				<!-- Wires to the bean which will actually call the MF Print -->
                <to uri="bean:specAsPdf"/>
                <!-- Saves the file onto the disk -->
                <to uri="file://?fileName=/tmp/tmp/${property.jobId}/${property.CamelSplitIndex}.pdf"/>
                <log message="${property.jobId} / ${property.CamelSplitIndex} Done !" loggingLevel="INFO"/>
            </split>
            <setHeader headerName="CamelExecCommandWorkingDir">
                <simple>/tmp/tmp/${property.jobId}</simple>
            </setHeader>
            <!-- Clean STDIN before launching scripts -->
            <transform>
                <constant/>
            </transform>
			<!-- TODO: port to itext to join the files -->
            <choice>
                    <when>
                        <simple>${exchangeProperty.outputFormat} == "pdf"</simple>
                        <to uri="exec:/bin/sh?useStderrOnEmptyStdout=true&amp;args=-c &quot;/usr/bin/pdfjoin --outfile /proc/self/fd/1 *.pdf&quot;"/>
                    </when>
                    <otherwise>
                        <to uri="exec:/bin/sh?useStderrOnEmptyStdout=true&amp;args=-c &quot;/usr/bin/zip - *.pdf&quot;"/>
                    </otherwise>
            </choice>
            <choice>
                <when>
                    <simple>${body.exitValue} != 0</simple>
                    <to uri="log:zip?level=ERROR"/>
                    <throwException message="Failed to zip the files" exceptionType="java.lang.RuntimeException"/>
                </when>
                <otherwise>
                    <to uri="file://?fileName=/tmp/output/${property.outputFilename}"/>
                </otherwise>
            </choice>
            <transform>
                <simple>${property.originalObject}</simple>
            </transform>
            <!-- Change state of job -->
            <script>
                <groovy>request.body.setState(org.georchestra.atlas.AtlasJobState.DONE)</groovy>
            </script>
            <!-- Sets all the necessary properties to send a mail, see AtlasMailComponent Java class -->
			<to uri="bean:prepareMail" />
			<!-- Actually send the mail -->
			<to uri="smtp://{{smtpHost}}:{{smtpPort}}/" />
        </route>
    </camelContext>
</beans>
