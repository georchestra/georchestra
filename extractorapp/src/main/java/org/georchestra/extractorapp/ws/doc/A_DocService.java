package org.georchestra.extractorapp.ws.doc;

import java.io.ByteArrayInputStream;
import java.io.DataOutputStream;
import java.io.File;
import java.io.FileFilter;
import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.FileOutputStream;
import java.io.FilenameFilter;
import java.io.IOException;
import java.io.InputStream;
import java.net.URL;

import javax.servlet.http.HttpServletResponse;
import javax.xml.transform.Source;
import javax.xml.transform.stream.StreamSource;
import javax.xml.validation.Schema;
import javax.xml.validation.SchemaFactory;
import javax.xml.validation.Validator;

import org.xml.sax.SAXException;

/**
 * This service is the basic template to handle the storage and the loading of a file on a temporary directory.
 * Some methods can be override to provide treatments specific to a file extension.
 * @author yoann buch  - yoann.buch@gmail.com
 *
 */

public abstract class A_DocService {
    
    /**
     * Document prefix helping to differentiate documents among others OS tmp files
     */
    protected static final String DOC_PREFIX = "geodoc";
    
    /**
     * files are stored in the OS tmp directory
     */
    private static final String DIR_PATH = System.getProperty("java.io.tmpdir"); 
    
    /**
     * Time (in minutes) before files are purged automatically from DIR
     */
    private static final int PURGE_TIMER_MIN = 10;
    
    /**
     * File extension. 
     */
    protected String _fileExtension;
    
    /**
     * MIME type.
     */
    private String _MIMEType;
    
    /**
     * File content. Can be altered
     */
    protected String _content;
    
    /**
     * File name. Can be altered otherwise default name is kept (the one generated by OS)
     */
    protected String _name;

    
    /*========================Public Methods====================================================*/
    
    /**
     * Subclasses have to provide their file extension name and MIME type
     * @param fileExtension
     */
    public A_DocService(final String fileExtension, final String MIMEType) {
        _fileExtension = fileExtension;
        _MIMEType = MIMEType;
    }
    
    /**
     * Store the given data
     * @param data raw data to be stored
     * @return file name
     * @throws DocServiceException
     */
    public String saveData(final String data) throws DocServiceException {
        
        // purge doc directory from old files
        purgeDocDir();
        
        _content = data;
        
        // actions to take before saving data
        preSave();
        
        // store file under a file and get its name
        String fileName = saveDataIntoFile(_content);
        
        return fileName;   
    }
    
    /**
     * Load the file corresponding to the file name in the service.
     * Content can be accessed via getContent, name via getName, and MIME type via getMIMEType
     * @param fileName file name
     * @throws DocServiceException
     */
    public void loadFile(final String fileName) throws DocServiceException {

        // check first if file exists
        if(!isFileExist(fileName)) {
            throw new DocServiceException("Requested file  does not exist.", HttpServletResponse.SC_NOT_FOUND);
        }
        
        // default, file name will the one generated by OS
        _name = fileName;
        
        // load file content
        _content = loadContent(fileName);
        
        // actions to take after loading the content
        postLoad();
    }
    
    /*========================Accessor Methods====================================================*/
    
    /**
     * Get the MIME type
     * @return String MIME type
     */
    public String getMIMEType() {
        return _MIMEType;
    }
    
    /**
     * Get the file content. Should be called once loadFile has been called.
     * @return String file content
     */
    public String getContent() {
        if(_content == null) {
            throw new RuntimeException("_content is null. Should be called after loadFile");
        }
        return _content;
    }
    
    /**
     * Get the file name (contains file extension). Should be called once loadFile has been called.
     * @return String file name
     */
    public String getName() {
        if(_name == null) {
            throw new RuntimeException("_name is null. Should be called after loadFile");
        }
        return _name;
    }
    
    /*========================Protected Methods - Variable algorithms==============================================*/
    
    /**
     * Must be override to take actions before the data are saved. <br />
     * Examples: valid data format or integrity, interpret or transform data.
     * @throws DocServiceException
     */
    protected void preSave() throws DocServiceException {
    }
    
    /**
     * Must be override to take actions once the file is load in memory <br />
     * Examples: parse the file to get the real file name
     * @throws DocServiceException
     */
    protected void postLoad() throws DocServiceException {
    }
    
    /**
     * Provide a method to its subclasses to determine if their content is valid based on a xsd schema
     * @param schemaURL
     * @return true: valid; false: not valid. No use to expect this return value. If the document is not valid a DocServiceException is thrown
     * @throws DocServiceException
     */
    protected boolean isDocumentValid(final String schemaURL) throws DocServiceException {
        try {
            
            InputStream dataToValid = new ByteArrayInputStream(getContent().getBytes("UTF-8"));
            
            // lookup a factory for the W3C XML Schema language
            SchemaFactory factory = SchemaFactory.newInstance("http://www.w3.org/2001/XMLSchema");
        
            // get the schema online.
            Schema schema = factory.newSchema(new URL(schemaURL));
    
            // prepare source to valid by the validator based on the schema
            Source source = new StreamSource(dataToValid);  
            Validator validator = schema.newValidator();
            
            // check if doc is valid
            validator.validate(source);
            return true;
        }
        catch (SAXException ex) {
            // occurs when validation errors happen
            throw new DocServiceException("File is not valid. " + ex.getMessage(), HttpServletResponse.SC_UNSUPPORTED_MEDIA_TYPE);
        } catch (IOException e) {
            e.printStackTrace();
        } 
        return false;
    }
    
    /*=====================Private Methods - Common to every DocService=========================================*/
    
    private void purgeDocDir() {

        File dir = new File(DIR_PATH);      
        if(!dir.exists()) {
            throw new RuntimeException(DIR_PATH + " dir not found");
        } 
        
        // prepare filter to get old files
        FileFilter filter = 
            new FileFilter() {
                                    public boolean accept(File file) {
                                        
                                        // has to be a geodoc file
                                        if(file.getName().contains(DOC_PREFIX)) {
                                            long currentTime = System.currentTimeMillis();
                                            long lastModified = file.lastModified();
                                            
                                            // has to have a time life above TIMER_MIN minutes
                                            if(currentTime - lastModified > PURGE_TIMER_MIN * 60 * 100) {
                                                return true;
                                            }
                                        }
                                        return false;                                       
                                    }
                                }; 
                                
        // get files thanks to the previous filter
        File[] fileList = dir.listFiles(filter);  
        
        // delete them
        for(File file : fileList) {        
            if(!file.delete()) {
                throw new RuntimeException("Could not delete file: " + file.getPath());
            }
        }
        
    }
    
    /**
     * Save the given data under a specific name and location
     * @param data data to be stored
     * @return file name
     */
    private String saveDataIntoFile(final String data) {
        String fileName = "";
        try {
            // file saved under: DOC_PREFIX + ID generated by OS + _fileExtension in the DIR_PATH
            File file = File.createTempFile(DOC_PREFIX, _fileExtension, new File(DIR_PATH));  
            file.deleteOnExit(); // will be purged when JVM stops
          
            // write content file as bytes
            DataOutputStream out = new DataOutputStream(new FileOutputStream(file));
            out.write(data.getBytes("UTF-8"));
            out.close();  
            
            fileName = file.getName();
            
        }
        catch(FileNotFoundException fnfExc) {
            fnfExc.printStackTrace();
        }
        catch(IOException ioExc) {
            ioExc.printStackTrace();
        }
      
        return fileName;
    }
    
    /**
     * Check that file exists in DIR_PATH
     * @param fileName
     * @return true: exists, false: not exists
     */
    private boolean isFileExist(final String fileName) {
        
        // file was stored previously in a known place
        File dir = new File(DIR_PATH);
        
        if(!dir.exists()) {
            throw new RuntimeException(DIR_PATH + " dir not found");
        } 
        
        // prepare filter to get the right file 
        FilenameFilter filter = 
            new FilenameFilter() {
                                    public boolean accept(File dir, String name) {
                                        
                                        return fileName.equals(name);
                                    }
                                }; 
                                
        // get file thanks to the previous filter
        String[] fileList = dir.list(filter);  
        
        return fileList.length == 1;
    }
    
    /**
     * Get file content of the given file stored in DIR_PATH
     * @param fileName file name
     * @return file content
     */
    private String loadContent(final String fileName) {

        File file = new File(DIR_PATH + "/" + fileName); 
        String content = "";
        
        try {
            FileInputStream  fis = new FileInputStream(file);
            
            // get file size
            long fileSize = file.length();
            if (fileSize > Integer.MAX_VALUE) {
                throw new IOException("File is too big");
            }

            // allocate necessary memory to store content
            byte[] bytes = new byte[(int) fileSize];
            
            // read the content in the byte array
            int offset = 0;
            int numRead = 0;
            while (offset < bytes.length && (numRead=fis.read(bytes, offset, bytes.length-offset)) >= 0) {
                offset += numRead;
            }
            
            // Ensure all the bytes have been read 
            if (offset < bytes.length) {
                throw new IOException("Could not completely read file " + file.getName());
            }
        
            // Close the input stream and return bytes
            fis.close();
            
            content = new String(bytes);
        }
        catch(FileNotFoundException fnfExc) {
            fnfExc.printStackTrace();
        }
        catch(IOException ioExc) {
            ioExc.printStackTrace();
        }

        return content;
    }

}
